
#### 引用与解引用

犹如之前所说，一个变量转移来转移去的实在是麻烦，所有就有了一种新的方式，借用，不获取他的所有权，就像你找邻居借用他的剪刀，用完之后在还回去，这个剪刀一直都是邻居的，而你只是借用了一下，用完之后就得还给邻居

使用 `&` 来借用一个值

```rust
fn main() {
	let x = 10;
	let y = &x;

	println!("{} {}", x, y);
	// 输出 10 10
}
```

这两个值打印出来是一样的，然而真的是这样吗

```rust
fn main() {
	let x = 10;
	let y = &x;
	
	assert_eq!(x, y);
	// 发现他们并不相等，而且会报错
}
```

这是因为是借用的，所以其实存储的是一个地址值，这个地址值指向的才是真实数据，所以两个变量存储的类型并不一样，所以无法进行比较，`x` 是一个 i32 类型 `y` 则是 `&i32` 类型，也就是 i32 的引用类型

如果想对比他俩的实际值到底一不一样就需要用到解引用了，使用 `*` 符号来进行引用，也就是去找到实际的值

```rust
fn main() {
	let x = 10;
	let y = &x;

	assert_eq!(x, *y);
	// 这回就没有问题了，因为他们的实际值是一样的，也是同样的类型
}
```

有了引用就可以很方便的借用值，而不去转移他的类型

```rust
fn main() {
	let s = String::from("test");
	let len = get_len(&s);

	println!("{} {}", s, len); // 这里 s 依然有效
	// 输出 test 4
}

fn get_len(s: &String) -> usize {
	s.len()
}
```

不过毕竟是借用，在没有经过主人的允许的情况下是不能对借来的东西进行修改的，还得这个东西可以被修改才行

```rust
fn main() {
	let x = 10;
    let y = &x;
    y = y + 1;
}
```

这样是不行的，有几个问题

1. x 并不可以被允许修改
2. y 也没得到允许能被修改
3. y 的值为引用类型，`&i32` 是不能做计算和复制为 `i32` 的

所以想要这段代码能允许我们就得先解决几个问题

```rust
fn main() {
	// 首先的这个东西可以被修改
	let mut x = 10;
	// 修改为可变引用，也就是得给主人说清楚借来可能会修改它
    let y = &mut x;
	// 解引用，找到实际值来进行修改，找到实际值进行相加运算
    *y = *y + 1;
}
```

不过得注意，**同一作用域，特定数据只能有一个可变引用**

```rust
let mut s = String::("test");

let s1 = &mut s;
let s2 = &mut s;
```

这样代码是会报错的，主要是为了避免数据竞争问题，毕竟有时候不知道哪一个引用就改了这个变量的值，还有一个问题就是，**可变引用与不可变引用不能同时存在**

```rust
let mut s = String::from("test");

let s1 = &mut s;
let s2 = &s;
let s3 = &s;

println!("{} {} {}", s1, s2, s3);
```

毕竟谁也不希望自己在借用一个东西的时候被另一个人修改了，如果他们不同时使用就可以了

```rust
let mut s = String::from("test");

let s1 = &mut s;
println!("{}", s1);
s1.push_str("haha");

let s2 = &s;
let s3 = &s;

println!("{} {}", s2, s3);
```

就不能同时用，我在用你也在用，你还可以改，这肯定不行，要么都可以用，都不能改

还有一种问题叫做**悬垂引用**，就是说这个值已经被释放了，但是这个指针依然存在，这个指针指向的内存可能不存在了，或者被别的变量重新使用了。不过 Rust 编译器在编译的时候帮助我们避免了这个问题，如果出现悬垂引用的做法就会报错

```rust
fn main() {
	let s1 = test();
}

fn test() -> &String {
	let s = String::from("test");// 创建了一个新字符串
	
	&s //返回了 s 的引用
}// s 变量被销毁了
```

这就是一个悬垂引用，如果这样写 Rust 便已经就会报错，返回了一个借用的值，但是已经找不到借用的值的来源了

所以，借用就同一时间，只能有一个可变引用被使用，或者多个不可变引用被使用，并且引用必须总是有效的
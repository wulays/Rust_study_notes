#### 模式匹配

模式匹配可以用来匹配字面值，或者用来解构枚举等，就像之前枚举中提到的，最常用的就是 `match` 和 `if let`，而 `if let` 相当于 `match` 的一个简化版，主要用于只关心一种匹配模式的情况，不过会失去穷尽性检查的功能

#### match 匹配

```rust
match target {
	模式1 => 表达式1,
	模式2 => {
		语句;
		语句;
		表达式2
	},
	_ => 表达式3
}
```

`_` 通配符代表着剩余的没显示写出来的模式都会被这个模式匹配到，因为 `match` 是穷尽的所以必须列出所有的可能，这里使用了 `_` 来匹配剩余的可能性，也就代表着只关心别的显示匹配的值，不过所以分支的返回类型一定需要一样

```rust
enum Coin {
	A,
	B,
	C,
	D
}

let coin = Coin::A;

// 这里匹配到了 A 所以会将 1 的值赋值给 num
let num = match coin {
	Coin::A => 1,
	Coin::C => 3,
	Coin::B => {
		println!("B");
		2
	},
	_ => 0
};

println!("{}", num);
```

因为是表达式，所以也会有返回值的，也可以用它来赋值，如果分支有多行代码就可以使用 `{}` 包裹，同时最后一行需要是一个表达式，除非每一个都没有返回，那就是隐式的返回一个 `()`

```rust
match coin {
	Coin::A => 1,
	Coin::B => {
		2
	},
	other => {
		println!("", other);
		-1
	}
}
```

除了使用 `_` 也可以使用一个变量名来代替，使用 `_` 和前面一样只是为了让 Rust 忽略未使用的变量

#### if let 匹配

有些时候只想 匹配一个模式，其他的都忽略的情况

```rust
let n = Some(10);
match n {
	Some(10) => {
		// do something
	},
	_ => ()
}
```

这个时候用 `match` 看起来就有些繁琐了，所以就可以用到 `if let` 

```rust
let n = Some(10);

if let Some(10) = n {
	println!("匹配到了");
}
```

当然除了固定使用一个值来进行匹配之外还可以将它写成一个变量

```rust
if let Some(x) = n {
	println!("{}", x);
}
```

不过也是一样的道理，如果不用这个值的话，就可以用 `_` 来进行忽略

即使使用这种方式也需要注意，这里其实相当于声明了一个新变量，如果用了同名变量则会导致遮蔽发生

```rust
// 匹配出来之前 n 是 Some(10)
if let Some(n) = n {
	println!("{}", n);
	// 匹配出来之后 n 是 10
}
// 匹配后出了作用域 n 又是 Some(10)
```

对于 `match` 类型也是一样的

```rust
// 匹配出来之前 n 是 Some(10)
match n {
	Some(n) => println!("{}", n); // 匹配出来之后 n 是 10
	_ => ()
}
// 匹配后出了作用域 n 又是 Some(10)
```

#### matches! 宏

除了这两种匹配方式之外，Rust 还提供了一个宏，用于将一个表达式和一个模式进行匹配，然后返回 `true` 或 `false`

```rust
let a = Coin::A;
let is_a = matches!(a, Coin::A);

//也可以去匹配一个值，同时判断更精细
let bar = Some(10);
matches!(bar, Some(x) if x > 2);
// 如果 bar 是 Some(5) 就会是 true 因为 5 > 2，如果，bar 是 Some(1) 或者 None 结果就会是false
```

这就很方便了，可以用来快速的检查一个值是否匹配某一个给定的模式，同时返回一个布尔值
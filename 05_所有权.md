####  所有权系统

所有权系统，Rust 的核心特性，它规定了如何管理内存，以往的编程语言通过手动管理内存或者垃圾回收机制来进行内存的管理

- 手动管理内存
	- 容易忘记释放
	- 多次释放
	- 使用已经释放过的内存（空悬指针）
- 垃圾回收
	- 垃圾回收的运行期间可能导致性能的损失
	- 无法完全消除所有内存错误

而 Rust 采用的是 所有权系统，**编译器在编译时会根据一系列规则进行检查**，因为是在编译期间，所有在程序运行期间，不会有任何的性能损失。缺点就是不咋好学

##### 堆与栈

在其他语言中可能不需要怎么了解堆与栈，对于Rust 这种系统编程语言就需要了，因为值存在堆上还是栈上影响到了程序的行为和性能

> 堆和栈的核心目标就是为程序在运行时提供可以使用的内存空间

###### 栈

栈可以理解为一个装羽毛球的套筒，不过只有一个方向的开口，装羽毛球和拿羽毛球都只能从一个口去拿，这也就有一个特性了，就是**后进先出**，最先放进去的羽毛球，得等后放的羽毛球都拿出去后才能拿出来，增加的羽毛球就叫做**进栈**，移除的就叫做出栈。

因为这种实现方式，所以栈中的数据就都必须时已知固定大小的内存空间，如果数据的大小是不知道的，那么在取出的时候就取不到想要的数据了

###### 堆

和栈不一样，对于未知可能变化的数据，就需要存储在堆上了

当向堆上放入数据的时候，需要请求一定大小的内存空间，操作系统就会在堆的某一个地方找到一个足够大的空位，把它标记为已使用，并且返回一个表示该位置地址的**指针**，这个过程叫做在堆上分配内存（分配） 

随后这个指针就会被存到栈中去，因为指针的值是已知且固定的，然后后续的过程中，就通过栈中的指针来获取数据在堆上的实际内存位置，进而访问该数据

所以，在栈上分配内存时要比堆上分配要快的，只需要将新数据放入栈顶就可以了。相比之下，在堆上分配内存就需要做很多的工作，因为首先要找到一块足够存放数据的内存空间，接着做一些记
录为下一次分配做准备，如果钱进程分配的内存不足时，还需要进行系统调用来申请更多内存。


##### 变量作用域

作用域是一个变量在程序中有效的范围, 假如有这样一个变量

```rust
{
	// 变量在这里时无效的，因为还没有被声明
	let x = 10; // 这里开始就有效了
	// 这些位置都是有效的
} // 从这开始作用域就结束了，变量 x 不在有效
```

变量创建开始就有效，知道离开作用域为止

Rust 中每一个值都被一个变量所拥有，该变量被称为值的**所有者**，一个值同时只能被一个变量所拥有，当所有者也就是变量离开作用域范围时，这个值就将被抛弃

##### 简单学习 String 类型

在这之前我们已经见过字符串字面值了就是使用双引号声明的

```rust
let s = "这是一个字符串字面量";
```

`x` 变量是硬编码进程序的字面值（类型为 `&str`），它很方便但也并不是所有场景都使用，因为是被硬编码进程序的，所以字符串字面量就是不可变的，但有时候我们需要一个可变的字符串，如程序运行时等待用户的输入的，这个时候就需要用到 Rust 提供的 `String` 类型了，它被分配到堆上，所以是可以动态增改的

```rust
let s = String::from("hello");
```

`::` 是一种调用操作符，这里为调用 `String` 模块中的 `from` 方法

```rust
let mut s = String::from("hello");
println!("{}", s);
// 输出 hello
s.push_str(" world"); // push_str 方法在字符串后方追加字面值
// 输出 hello world
println!("{}", s);
```

##### 所有权

如之前所说，Rust 中一个值只能被一个变量所拥有

```rust
let x = 10;
println!("{}", x); // 输出 10
let y = x;
println!("{} {}", x, y); // 输出 10 10
```

这是什么情况，我们不是说一个值只能被一个变量所拥有吗，并没有转移所有权。

是因为，首先将 `10` 绑定给了 `x`，然后有拷贝了 `x` 的值给到了 `y`，因为整数类型是 Rust 的基本数据类型，是固定大小的简单值，都被存储在了栈中，所以就都是通过了 **自动拷贝** 的方式来赋值，所以并不需要转移所有权

```rust
let s1 = String::from("test");
let s2 = s1; // s1 这里开始无效

println!("{}", s2);
```

这个时候就发生了所有权的转移了，这个时候 `s1` 就已经无效了，比较 `String` 不是基本数据类型，而且存储在了堆上，就不能自动拷贝了

因为 `String` 类型数据是存储在堆上的，存在栈上的是 堆指针、字符串长度、字符串容量组成的，堆指针，就指向了他的堆上的真实数据，如果要整个拷贝的话就得拷贝 栈上的还有堆上的数据，这就会很影响性能了，因为是**深拷贝**，而如果只拷贝栈上的就违反了之前说的规则，**一个值只允许一个所有者**（堆上的真实字符串数据），有了两个所有者就肯定不行了

为什么一个值不能拥有两个所有者呢，因为当变量离开作用域时，Rust 会自动调用 `drop` 函数并清理堆内存，如果这个时候有了两个 `String` 变量指向了同一个位置，就会有一个问题，当两个变量都离开作用域时，就都会尝试去释放相同的内存，就会导致 **二次释放** 的错误

Rust 的解决方式就是： 当 `s1` 被赋予 `s2` 时，就认为  `s1` 不在有效，而当 `s1` 离开作用域时也就不用再去调用 `drop` 了

##### 深拷贝

```rust
let s1 = String::from("test");
println!("", s1); // 这样是可以的因为 s1 的所有权依然在，并没有被转移
let s2 = s1;

println!("", s1); // 这样是不行的，Rust 会报错，因为 s1 的所有权已经转移给了 s2
// 错误 value borrowed here after move
```

如果想要复制一个怎么办呢，又不给自动拷贝，因为 Rust 不会自动进行深拷贝，这个时候就需要去 `clone` 了，而不仅仅是复制栈上的数据

```rust
let s1 = String::from("test");
let s2 = s1.clone();

println!("{} {}", s1, s2);
```

这个时候两个值就都有效了

##### 浅拷贝

浅拷贝只发生在栈上，性能很高，而且随处可见，如

```rust
let x = 10;
let y = x;
```

这里就发生了一次浅拷贝，可是我们并没有去调用 `clone`，这是因为 Rust 有个 `Copy` 的特性，自动的去做了这件事

常见的 `Copy` 类型

- 所有整形
- 浮点型
- 布尔型
- 字符型
- 元组，但是只限于包含的所有类型都有 `Copy` 特性的
	- (i32, i32) 这种就有
	- (i32, String) 这种就没有
- 不可变引用 `&T` 类型
	- `mut &T` 类型就不行，因为是可变引用

#### 函数的传值与返回

当值传递给函数时也会发生  移动所有权或者复制，就像 `let` 语句一样

```rust
fn main() {
	let s = String::from("test");

	test1(s);  // s 的所有权转移到了函数里面
	// s 就无效了
	
	let x = 10;
	test2(x); // x 应该被移动的，但是因为是 Copy 类型，所有这里复制了一个值
	// 这里 x 可以继续用

	let s1 = String::from("demo");
	let s2 = test3(s1); // 这里 s1 无效了，同时 s2 有效了，得到了 test3 转移的所有权

}
fn test1(s: String) {

}
fn test2(x: i32) {

}

fn test3(s: String) -> String {
	s // 将所有权返回出去了
}

```

为了避免内存的不安全性，总把一个值传来传去，有时候还是挺麻烦的，不过也有新功能解决这个问题 **借用**
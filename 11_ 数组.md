#### 数组

在 Rust 中数组是一种存储相同元素类型的列表，存储在栈上，所以他的长度是固定的，使用场景就是已知的固定值，如一个周的记录

```rust
let weeks1 = [1, 2, 3, 4, 5, 6, 7];
// 或者
let weeks2 = [
	"星期一",
	"星期二",
	"星期三",
	"星期四",
	"星期五",
	"星期六",
	"星期日",
];
```

当然也可以显示的对数组进行声明

```rust
let foo: [i32; 5] = [1, 2, 3, 4, 5];
```

采用 `[]` 的这种声明方式，`i32` 是元素类型，分号后面是数组的长度，也侧面的说明了，数组的元素类型和长度需要统一

如果要创建一个固定初始值的元素则可以这样写

```rust
let foo = [10; 5];
// [10, 10, 10, 10, 10]
```

这种写法就比写相同的多次简单多了，当然如果数组的元素不是基本数据类型的话，采用这种方式声明也会出现问题

```rust
let foo = [String::from("test"); 8];
```

这样也是会报错的，因为这样的写法底层其实就是一个一个的去 `Copy` 出来的，而 `String` 类型并没有去实现 `Copy`的深拷贝

可是还是想拥有这种简单的写法，总不能真的写一对一模一样的代码吧，这个时候就可以考虑使用`std::array::from_fn`

```rust
let array: [String; 8] = std::array:from_fn(|_i| String::from("test"));
```

这里用到了匿名函数，后续在去理解，只要知道有种这写法就行

和元组一样访问元素通过索引，不过不采用 `.` 操作符了，用的是 `[]` 加上索引的方式

```rust
let foo = [1, 2, 3, 4, 5];

let bar = foo[0];
// 1
```

数组的索引下标从 `0` 开始

当然虽然可以使用索引访问，但是还得注意一个问题就是，越界访问，如我们只有一个 `2` 位数的数组，我们却用下标 `2` 甚至更大的数去访问，这个时候程序就会崩溃了

```rust
let foo = [1, 2];

// 程序会报错因为最大索引才为 1
let bar = foo[2];
```

##### 切片

之前有说到切片，也就是引用集合中的部分连续片段，数组也是可以切片的，语法也一样

```rust
let foo = [1, 2, 3, 4, 5];

let slice = &foo[1..3];
```

> 在别的语言学到的数组就是有点区别的了，可以动态新增什么的，在Rust也有的，不过叫做 `Vector` 不过因为是动态的，所以存储在堆上，性能也就没有数组这么好了，它和 `String` 类型还是挺像的，都属于集合类型
## 基本概念

和别的编程语言一样 Rust 也是采用 `main` 函数为入口函数，如下该函数目前无返回值

```rust
fn main() {
	// dosomething...
}
```

想要在控制台输出使用 `println!` 这不是一个函数，而是一个宏，这里可以先不管，就当函数用

```rust
fn main() {
	println!("Hello world!");
}
```

这样就可以在控制台打印出 `Hello world` 了，同时 Rust 使用 `{}` 来作为格式化输出占位符，其它语言可能使用的是 `%s`，`%d`，`%p` 等，由于 `println!` 会自动推导出具体的类型，因此无需手动指定

```rust
fn main() {
	println!("{} {}", 1, "Hello")
	// 这会输出 1 Hello
}
```

> 宏编程（Macro programming）是一种在编译时进行代码生成或转换的技术。在 Rust 中，宏允许编写一种模式，这种模式将展开成特定的代码块，从而避免了重复的代码编写，同时也能提供强大的抽象能力。

## 变量与数据类型

在 Rust 中，变量扮演着数据存储的角色，它们是分配给存储值的内存空间的名称。
### Rust 中的变量声明和绑定

在 Rust 中，变量默认情况下是不可变的。一旦给不可变变量绑定了值，就无法更改它。**不可变性 (Immutability) 默认原则**

##### 变量声明

使用 `let` 关键字来声明一个变量，如果没有给到初始值就需要显示的声明类型了，之后在去给这个变量绑定相同类型的值

```rust
let x: i32; // 声明一个32位有符号整数变量 x，未初始化
let y: u32; // 声明一个32位无符号整数变量 y，未初始化
let z: bool; // 声明一个布尔型变量 z，未初始化
// 变量的绑定
x = -10;
y = 10;
z = true;
```

为什么叫变量的绑定呢，因为这涉及到一个概念叫 **所有权**，简单来讲，任何内存对象都是有主人的，而且一般情况下完全属于它的主人，绑定就是把这个对象绑定给一个变量，让这个变量成为它的主人

- **`let`** 关键字:  用于声明新变量。

> **注意:** 数据类型定义了变量可以保存的数据种类和所占的内存大小。

上面就提到了变量是不可变的，这里就给一个变量的不可变性示例

```rust
// 此处没有指定x的类型，编译器会默认根据a的值为a推断类型：i32，有符号32位整数
let x = 10;
// x = 20; // 错误！不可变变量不能被赋予新值
```

如果不标注类型，Rust 编译器会自动推断变量的数据类型，这个过程被称为**类型推导**

##### 可变变量 (Mutable Variables)

如果想让一个变量可以被重新绑定的话就可以使用可变性关键字 **`mut`** 来进行声明，mut是mutable的缩写

```rust
let mut x = 10; // 声明一个可变变量 x
x = 20; // 正确！可变变量可以被重新赋值
```

> 为什么要手动设置变量可变性，因为将本身无需改变的变量声明为不可变在运行期会避免一些多余的 `runtime` 检查等

## 变量的作用域与遮蔽

在 Rust 中，变量的作用域是指变量在程序中有效的区间。变量仅在它们被声明的代码块内有效。
变量的遮蔽就是可以声明一个同名的变量来对上方的变量进行遮蔽，也可以理解为覆盖了，但并**不是重新赋值**

```rust
let x = "str";
let x = 10; // 这样是可以的重新声明的
{
    let x = 15; // 新的作用域中的x遮蔽了外部的x
    println!("{}", x); // 输出: 15
}
println!("{}", x); // 输出: 10
```

这样的好处是可以在某些时候不用取一些无关紧要的变量名，比如想要一个格式化后的变量

- 使用 `{}` 创建一个新的作用域。
- 在不同作用域声明的同名变量会遮蔽外层作用域的变量。

#### 变量和常量的区别

**常量**，与不可变变量一样，常量也是绑定后就不允许修改值，但也有一些区别

1. 常量不允许使用 `mut`，不仅仅时默认不可变，是始终不可变，因为在编译完成后，就已经确定了常量的值
2. 常量使用 `const` 关键字声明，而不是 `let`，并且值的类型必须标注

```rust
const MAX_COUNT: u32 = 100_000_000;
```

常量的命名约定是全部大写，并使用下划线进行分分隔单词，在声明的作用域内，常量在程序的允许过程中都有效，对于需要多出代码共享一个不可变值的时候很有用。对于将来需要修改值是也只需要修改常量就可以了，不需要每个地方都修改

#### 其他

##### 未使用的变量

在 Rust 中，如果你声明了一个变量但没有使用它，会出现警告。如果你想要避免这个警告，可以使用下划线 `_` 作为变量名的前缀。

```rust
let _unused_variable = "这样就不会有警告了";
```


> 注意, 只使用 `_` 和使用以下划线开头的名称有些微妙的不同：比如 **`_x` 仍会将值绑定到变量，而 `_` 则完全不会绑定**。
##### 变量解构

`let` 表达式不仅能用于变量的绑定，还能用于复杂变量的结构，也就是从一个复杂的变量中匹配出该变量的一部分

```rust
fn main() {
	let (a, mut b) = (true, false);
	// a 为不可变，b 为可变，因为用了 mut 关键字
    println!("{} {}", a, b);

    b = true;

    println!("{} {}", a, b);
}
```

在 `Rust 1.59` 版本之后还有可以在赋值语句的左侧使用，元组、切片、结构体模式

```rust
// 这里声明了一个结构体可以先不管他
struct Struct {
    e: i32
}

fn main() {
	// 先声明了变量，但是并没有绑定值
	let (a, b, c, d, e);
	// 这里 a, b 解构了右侧的元组并绑定值
	(a, b) = (1, 2);
	// 这里 .. 表示忽略了中间值，而 _ 表示忽略一个元素
	[c, .., d, _] = [1, 2, 3, 4, 5];
	// 这里就只匹配了结构体中的 e 其他的则忽略
	Struct { e, .. } = Struct { e: 5 };

	println!("{} {} {} {} {}", a, b, c, d, e);
}
```

这里和之前的结构方式是一样的，不过之前时重新绑定，而这里是对之前声明的变量再绑定
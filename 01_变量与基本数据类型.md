## 基本概念

和别的编程语言一样 Rust 也是采用 `main` 函数为入口函数，如下该函数目前无返回值

```rust
fn main() {
	// dosomething...
}
```

想要在控制台输出使用 `println!` 这不是一个函数，而是一个宏，这里可以先不管，就当函数用
。同时 Rust 使用 `{}` 来作为格式化输出占位符，其它语言可能使用的是 `%s`，`%d`，`%p` 等，由于 `println!` 会自动推导出具体的类型，因此无需手动指定

> 宏编程（Macro programming）是一种在编译时进行代码生成或转换的技术。在 Rust 中，宏允许编写一种模式，这种模式将展开成特定的代码块，从而避免了重复的代码编写，同时也能提供强大的抽象能力。

```rust
fn main() {
	println!("Hello world!");
}
```

## 变量与数据类型

在 Rust 中，变量扮演着数据存储的角色，它们是分配给存储值的内存空间的名称。
### Rust 中的变量声明和绑定

**不可变性 (Immutability) 默认原则**，在 Rust 中，变量默认情况下是不可变的。一旦给不可变变量绑定了值，就无法更改它。

##### 变量声明

- **`let` 关键字**: 用于声明新变量。
- **显式类型标注**: 可选地，变量类型可以被显式地标注。
- **类型推导**: 如果不标注类型，Rust 编译器会自动推断变量的数据类型。

```rust
let x: i32; // 声明一个32位有符号整数变量 x，未初始化
let y: u32; // 声明一个32位无符号整数变量 y，未初始化
let z: bool; // 声明一个布尔型变量 z，未初始化
// 变量的绑定
x = -10;
y = 10;
z = true;
```

> **注意:** 数据类型定义了变量可以保存的数据种类和所占的内存大小。

为什么叫变量的绑定呢，因为这涉及到一个概念叫 **所有权**

> **所有权**，简单来讲，任何内存对象都是有主人的，而且一般情况下完全属于它的主人，绑定就是把这个对象绑定给一个变量，让这个变量成为它的主人

**变量的不可变性示例**

```rust
// 此处没有指定x的类型，编译器会默认根据a的值为a推断类型：i32，有符号32位整数
let x = 10;
// x = 20; // 错误！不可变变量不能被赋予新值
```

##### 可变变量 (Mutable Variables)

- **可变性关键字 `mut`**: 使用 `mut` 关键字可以使变量变为可变。mut是mutable的缩写
- **修改可变变量**: 当变量为可变时，可以对其赋予新值。

```rust
let mut x = 10; // 声明一个可变变量 x
x = 20; // 正确！可变变量可以被重新赋值
```

> 为什么要手动设置变量可变性，因为将本身无需改变的变量声明为不可变在运行期会避免一些多余的 `runtime` 检查等

## 变量的作用域与遮蔽

在 Rust 中，变量的作用域是指变量在程序中有效的区间。变量仅在它们被声明的代码块内有效。
- 使用 `{}` 创建一个新的作用域。
- 在不同作用域声明的同名变量会遮蔽外层作用域的变量。

```rust
let x = "str";
let x = 10; // 这样是可以的重新声明的
{
    let x = 15; // 新的作用域中的x遮蔽了外部的x
    println!("{}", x); // 输出: 15
}
println!("{}", x); // 输出: 10
```

#### 其他

##### 未使用的变量

在 Rust 中，如果你声明了一个变量但没有使用它，会出现警告。如果你想要避免这个警告，可以使用下划线 `_` 作为变量名的前缀。

```rust
let _unused_variable = "这样就不会有警告了";
```
##### 变量解构

可以使用模式匹配来解构元组或结构体，这种方式允许你访问复合类型的内部值。

```rust
let (a, b) = (1, 2); // 解构一个元组
println!("a = {}, b = {}", a, b); // 输出: a = 1, b = 2
```


#### 变量和常量的区别

**常量**，与不可变变量一样，常量也是绑定后就不允许修改值，但也有一些区别

1. 常量不允许使用 `mut`，不仅仅时默认不可变，是始终不可变，因为在编译完成后，就已经确定了常量的值
2. 常量使用 `const` 关键字声明，而不是 `let`，并且值的类型必须标注

```rust
const MAX_COUNT: u32 = 100_000_000;
```

常量的命名约定是全部大写，并使用下划线进行分分隔单词，在声明的作用域内，常量在程序的允许过程中都有效，对于需要多出代码共享一个不可变值的时候很有用。对于将来需要修改值是也只需要修改常量就可以了，不需要每个地方都修改

### 数据类型

Rust 是一种静态类型语言，这意味着每个变量在声明时都必须指定数据类型，这使得编译器能够在编译时检查类型的正确性。
#### 常见数据类型

- **整型**: 用来表示整数的数据类型。
    - 有符号整型（`i<size>`）: 能存储正负整数。
    - 无符号整型（`u<size>`）: 仅存储正整数。
    - `<size>`: 指定位数，如 `i8`, `u32`。
    - `usize`/`isize`: 依据操作系统架构（32 位或 64 位）定义大小。
- **浮点型**: 存储小数点数值，分为单精度（`f32`）和双精度（`f64`）。
- **布尔型**: 表示逻辑真（`true`）和假（`false`）。
- **字符型**: 存储单个 Unicode 标量值，如 `'a'`、`'我'`、`'😊'`。
- **字符串型**:
    - `String`: 可变、可增长、拥有所有权的 UTF-8 文本字符串。
    - `&str`: 不可变的字符串切片，经常用于借用文本。
- **数组**: 固定大小的同类型数据集合，如 `[i32; 5]` 表示一个包含 5 个 `i32` 类型元素的数组。
- **元组**: 可存储多种类型的固定数量集合。
	- 可以包含不同数据类型的固定数量元素，例如 `(32, 'a')`



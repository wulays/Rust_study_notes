## 变量与数据类型

在 Rust 中，变量扮演着数据存储的角色，它们是分配给存储值的内存空间的名称。
### 数据类型

Rust 是一种静态类型语言，这意味着每个变量在声明时都必须指定数据类型，这使得编译器能够在编译时检查类型的正确性。
#### 常见数据类型

- **整型**: 用来表示整数的数据类型。
    - 有符号整型（`i<size>`）: 能存储正负整数。
    - 无符号整型（`u<size>`）: 仅存储正整数。
    - `<size>`: 指定位数，如 `i8`, `u32`。
    - `usize`/`isize`: 依据操作系统架构（32 位或 64 位）定义大小。
- **浮点型**: 存储小数点数值，分为单精度（`f32`）和双精度（`f64`）。
- **布尔型**: 表示逻辑真（`true`）和假（`false`）。
- **字符型**: 存储单个 Unicode 标量值，如 `'a'`、`'我'`、`'😊'`。
- **字符串型**:
    - `String`: 可变、可增长、拥有所有权的 UTF-8 文本字符串。
    - `&str`: 不可变的字符串切片，经常用于借用文本。
- **数组**: 固定大小的同类型数据集合，如 `[i32; 5]` 表示一个包含 5 个 `i32` 类型元素的数组。
- **元组**: 可存储多种类型的固定数量集合。
	- 可以包含不同数据类型的固定数量元素，例如 `(32, 'a')`

### Rust 中的变量声明和绑定

**不可变性 (Immutability) 默认原则**，在 Rust 中，变量默认情况下是不可变的。一旦给不可变变量绑定了值，就无法更改它。

##### 变量声明

- **`let` 关键字**: 用于声明新变量。
- **显式类型标注**: 可选地，变量类型可以被显式地标注。
- **类型推导**: 如果不标注类型，Rust 编译器会自动推断变量的数据类型。

```rust
let x: i32; // 声明一个32位有符号整数变量 x，未初始化
let y: u32; // 声明一个32位无符号整数变量 y，未初始化
let z: bool; // 声明一个布尔型变量 z，未初始化
```

> **注意:** 数据类型定义了变量可以保存的数据种类和所占的内存大小。

**变量的不可变性示例**

```rust
let x = 10;
// x = 20; // 错误！不可变变量不能被赋予新值
```

##### 可变变量 (Mutable Variables)

- **可变性关键字 `mut`**: 使用 `mut` 关键字可以使变量变为可变。
- **修改可变变量**: 当变量为可变时，可以对其赋予新值。

```rust
let mut x = 10; // 声明一个可变变量 x
x = 20; // 正确！可变变量可以被重新赋值
```

## 变量的作用域与遮蔽

在 Rust 中，变量的作用域是指变量在程序中有效的区间。变量仅在它们被声明的代码块内有效。
- 使用 `{}` 创建一个新的作用域。
- 在不同作用域声明的同名变量会遮蔽外层作用域的变量。

```rust
let x = 10;
{
    let x = 15; // 新的作用域中的x遮蔽了外部的x
    println!("{}", x); // 输出: 15
}
println!("{}", x); // 输出: 10
```

#### 其他

##### 未使用的变量

在 Rust 中，如果你声明了一个变量但没有使用它，会出现警告。如果你想要避免这个警告，可以使用下划线 `_` 作为变量名的前缀。

```rust
let _unused_variable = "这样就不会有警告了";
```
##### 变量解构

可以使用模式匹配来解构元组或结构体，这种方式允许你访问复合类型的内部值。

```rust
let (a, b) = (1, 2); // 解构一个元组
println!("a = {}, b = {}", a, b); // 输出: a = 1, b = 2
```
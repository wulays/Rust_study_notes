#### 语句与表达式

语句就是会执行一些操作但是不会返回一个值，例如我没之前使用的，声明语句

```rust
fn main() {
	let x = 10;
}
```

这就是一个语句，他完成了一个具体的操作，但是并没有返回值，如

```rust
let x = (let y = 10);
```

这样就是不行的，因为 `let` 是语句，也没有返回值，也就不能绑定给别的值

表达式就不一样了，表达式会先进行求值，然后再返回，如

```rust
fn main() {
	let x = 1 + 1;
}
```

这里 `1 + 1` 就是一个表达式，然后计算得到的值再赋值给变量，因为表达式也可以是语句的一部分其实如之前一样 `let x = 10;` 这里的`10` 其实也是一个表达式，先进性求值，得到了`10` 然后返回，只是不太直觉

用花括号包起来也是一个表达式，调用函数也是表达式，调用宏也是，因为会返回一个值

```rust
fn main() {
	let x = {
		let y = 10;
		y + 1
	};
	println!("{x}");
	// 输出11
}
```

`{}` 之所以是表达式，是因为最后一行是表达式，不过注意不能加上 `;` 如果加上了就成了语句了，只要表达式后面加上了 `;` 就不会返回一个值了，如果表达式不返回值的话也会隐式的返回一个 `()`。

甚至 `if` 也是表达式

```rust
fn main() {
	let is_true = true;

	let x = if is_true {
		9 + 1
	} else {
		0
	};

	println!("{x}");
	// 输出 10 因为 is_true 是 true
}
```


#### 函数

函数我们已经用过了`main` 函数，主要就是为了执行特定的代码块，可以拥有输入参数，还能返回值，使用 `fn` 关键字来定义一个函数

```rust
fn add(x: i32, y: i32) -> i32 {
	x + y
}
```

这里就使用 `fn`关键字定义了一个名为 `add` 的函数，参数分别是 `x` 和 `y` 参数的类型都是 `i32` ，最后使用表达式返回一个值，返回值的类型也是 `i32`，一切都是这么顺其自然

> 在 Rust 中 函数名称和变量都是使用的蛇形命名法，缩略词用全小写：`is_xid_start`。

因为 Rust 是强类型的语言，所以每一个函数的参数都需要标注出具体的类型

```rust
fn fun_1(a: i32, b: bool) {
	//...
}
fn fun_2(c: f64, d: u32) {
	//...
}
```

之前也提到过，函数也是表达式，所以也会返回值，不过在没有返回值的时候可以不用标注函数的返回值类型，这样的话就是隐式的去返回一个 `()` 了，同时在函数中，除了可以在末尾使用表达式进行返回之外还可以使用 `return` 来进行提前返回

```rust
fn add(x: i32, y: i32) -> i32 {
	if x >= 10 {
		return x
	}
	x + y
}

fn main() {
	let x = add(1, 2);
	let y = add(10, 1);

	println!("{x}, {y}");
	// 3, 10
}
```

当执行到函数内的`return`语句时，函数会立即结束，并将`return`后的值返回给调用者

> 单元类型其实就是一个 零长度的元组，没什么作用，就是占位，表达一个函数没有返回值

- 函数没有返回值，那么返回一个 `()`
- 通过 `;` 结尾的语句返回一个 `()`

当然也可以标注上类型，显示的返回一个 `()`

```rust
fn test() -> () {
	1 + 1;
}
```

虽然写了一个表达式，但是用 `;` 结尾了变成语句了，所以这里就是返回一个 `()` 了，当然还有一种情况，如

```rust
fn add(x: i32, y: i32) -> i32 {
	x + y;
}
```

这样是会报错的，因为预期返回的是一个 `i32` 然而实际是隐式的返回了一个 `()`，所以在 Rust中一定要去严格的区分**表达式**和**语句**的区别

##### 永不返回的发散函数

当 `!` 作为函数的返回值类型时，表示该函数永远不会返回，这很特别，一般用于导致程序崩溃的函数如

```rust
fn dead_end() -> ! {
	panic!("程序崩溃了");
}
```

或者为一个无限循环，因为循环永远没有跳出所以函数也不会返回

```rust
fn forever() -> ! {
	loop {
	
	};
}
```

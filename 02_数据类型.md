### 数据类型

Rust 是一种静态类型语言，这意味着每个变量在声明时都必须指定数据类型，这使得编译器能够在编译时检查类型的正确性。
##### 类型的推导

然而在前面的时候我们发现并不是在声明变量的时候必须得指定类型的，这是因为 Rust 编译器根据变量的值和上下文中的使用方式帮助了我们来**自动推导**出了变量的类型。当然也并不是所有时候都可以推导出来的，这个时候就需要帮他一把了，手动的去给予一个类型标注

```rust
let guess = "42".parse().expect("Not a number!");
```

这个时候就会报错了，`parse` 是为了转换数据类型，后面的可以先不管，然后这个时候 编译器却不知道我们想要的是什么类型了，浮点，整形，还是字符串，这个时候就需要帮他一把了

```rust
// 显示的类型标注
let guess: i32 = "42".parse().expect("Not a number!");

// 这种方式也可以，泛型
let guess = "42".parse::<i32>().expect("Not a number!");
```


#### 整形

**整数**就是没有小数部分的数字，例如之前使用的 `i32`，表示有符号的 32位整数，而 `i` _integer_ 表示有符号，`u` _unsigned_ 表示无符号。**无符号数**表示数字只能取正数和0，而**有符号**则表示数字可以取正数、负数还有0

当很明确数字为正数的时候就可以使用 `u` 了， 当然，Rust 整形默认使用的是 `i32`，如 `let a = 10;` 这里 `a` 就是 `i32` 类型

| 长度    | 有符号类型   | 无符号类型   |
| ----- | ------- | ------- |
| 8 位   | `i8`    | `u8`    |
| 16 位  | `i16`   | `u16`   |
| 32 位  | `i32`   | `u32`   |
| 64 位  | `i64`   | `u64`   |
| 128 位 | `i128`  | `u128`  |
| 视架构而定 | `isize` | `usize` |

##### 整型溢出

什么叫溢出，就是一个杯子，本来能装 500毫升的水，倒了 510 毫升的水，多的溢出来的就叫做溢出，同理，有一个 `u8` 能存放 0-255 的值，这个时候存储了一个 256 这个时候就会发生整型溢出了。

```rust
// 这样会溢出
let x: u8 = 256;
```

而这一行为，在 Rust 中有两种表现，一种是 `debug` 模式 也就是不使用 `--release` 参数的时候，这个时候 编译器就会去检查是否存在这个问题，如果存在则在编译时就会失败退出。然而如果使用了这个参数， 就不会去检测溢出了，如果有溢出则会按照补码循环溢出的规则进行处理，例如时 `u8` 如果给了 256 就会循环，变为0，如果是 257 则是 1，这个时候程序不会失败退出了，但是变量的值就可能不是你所期望的值了

当然标准库也提供了一些方法用来处理可能发生的溢出，这里仅供参考

- 使用 `wrapping_*` 方法在所有模式下都按照补码循环溢出规则处理，例如 `wrapping_add`
- 如果使用 `checked_*` 方法时发生溢出，则返回 `None` 值
- 使用 `overflowing_*` 方法返回该值和一个指示是否存在溢出的布尔值
- 使用 `saturating_*` 方法，可以限定计算后的结果不超过目标类型的最大值或低于最小值，例如:

#### 浮点型

**浮点类型数字** 就是带有小数点的数字，和整型声明方式一样，不过浮点只有 `f32` 和 `f64`，也就代表着 32 位和64位大小。默认为 `f64`，在现代的CPU 中速度和 `f32` 几乎相同了，同时精度更高，`f32` 类型是单精度浮点型，`f64` 为双精度。

```rust
fn main() {
	// 默认是 f64 所以这里就不显示指定类型了
	let f1 = 20.1;
	// 这里需要显示指定
	let f2: f32 = 20.2;
}
```

一般来说使用 `f64` 就可以了

当然浮点数有时候其实是有一些问题的，因为浮点数往往是想要的数字的近似表达，它是基于二进制来实现的，表达有些小数的时候就不够精确例如 `0.1`

```rust
fn main() {
	// 这得到的结果并不是 0.3
	println!("{} + {} = {}", 0.1, 0.2, 0.1 + 0.2);
	// 0.1 + 0.2 = 0.30000000000000004
}
```

除了不够精确之外，还有一些反直觉的问题，因为浮点数也就是小数，再我们看来是可以进行比较的，也诚然确实可以使用 `>` `<` 等比较运算符来进行比较。但是有些时候却并不是这样的。

```rust
fn main() {
	println!("{} + {} = {}", 0.1, 0.2, 0.1 + 0.2 == 0.3);
	// 0.1 + 0.2 = false
}
```

因为精度的问题，他们并不严格相等，可能再小数点很多位后存在误差。所以就得格外的小心只能尽量避免小苏的相等比较，如果一定要比较的话也可以考虑使用这种方式

```rust
fn main() {
	println!("{} + {} = {}", 0.1, 0.2, (0.1_f64 + 0.2 - 0.3).abs() < 0.00001);
	// 0.1 + 0.2 = false
}
```

虽然默认为 `f64` 类型但是再进行链式调用或者复杂表达式的时候，编译器就还是需要一些标注来帮助他进行类型的推断所以这里显示的标注了一个 `f64`

然而如果是 `f32` 去做比较就没问题

```rust
fn main() {
	println!("{} + {} = {}", 0.1, 0.2, 0.1_f32 + 0.2_f32 == 0.3_f32);
	// 0.1 + 0.2 = true
}
```

为什么会这样，因为精度么那么高，所以小数点非常后面的鹅一些变化就没有了，所以就对了，哇偶，真的和直觉完全不一样了

> 浮点数往往是想要的数字的近似表达因为浮点数是基于二进制来实现的，表达有些小数的

#### NaN

`NaN` (Not a number) 不是一个数，豁，见名知意，是浮点数计算中的一种特殊值，用于表示某些未定义或无法表示的计算结果。例如，当一个数被零除或负数取平方根时，结果不是一个实数，此时通常会返回 `NaN`

```rust
fn main() {
	// 零除以零
	println!("{}", 0.0 / 0.0);
	// 负数开平方
	println!("{}", (-1.0_f64).sqrt());
}
```

NaN 与任何值（包括 NaN 自身）的比较都是假的，即 `nan == nan` 结果是 `false`，NaN 通常用在需要表示错误或者异常情况的浮点计算中

由于 NaN 的这些特殊性质，编程时需要特别注意处理 NaN，以防止不合预期的行为。在 Rust 中，可以使用 `is_nan()` 方法来检查一个值是否是 NaN

```rust
if nan.is_nan() {
    println!("Value is NaN");
}
```

#### 其他

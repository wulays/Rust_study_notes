### 数据类型

Rust 是一种静态类型语言，这意味着每个变量在声明时都必须指定数据类型，这使得编译器能够在编译时检查类型的正确性。
##### 类型的推导

然而在前面的时候我们发现并不是在声明变量的时候必须得指定类型的，这是因为 Rust 编译器根据变量的值和上下文中的使用方式帮助了我们来**自动推导**出了变量的类型。当然也并不是所有时候都可以推导出来的，这个时候就需要帮他一把了，手动的去给予一个类型标注

```rust
let guess = "42".parse().expect("Not a number!");
```

这个时候就会报错了，`parse` 是为了转换数据类型，后面的可以先不管，然后这个时候 编译器却不知道我们想要的是什么类型了，浮点，整形，还是字符串，这个时候就需要帮他一把了

```rust
// 显示的类型标注
let guess: i32 = "42".parse().expect("Not a number!");

// 这种方式也可以，泛型
let guess = "42".parse::<i32>().expect("Not a number!");
```


#### 整形

**整数**是没有小数部分的数字，例如之前使用的 `i32`，表示有符号的 32位整数，而 `i` _integer_ 表示有符号，`u` _unsigned_ 表示无符号。**无符号数**表示数字只能取正数和0，而**有符号**则表示数字可以取正数、负数还有0

当很明确数字为正数的时候就可以使用 `u` 了， 当然，Rust 整形默认使用的是 `i32`，如 `let a = 10;` 这里 `a` 就是 `i32` 类型

| 长度    | 有符号类型   | 无符号类型   |
| ----- | ------- | ------- |
| 8 位   | `i8`    | `u8`    |
| 16 位  | `i16`   | `u16`   |
| 32 位  | `i32`   | `u32`   |
| 64 位  | `i64`   | `u64`   |
| 128 位 | `i128`  | `u128`  |
| 视架构而定 | `isize` | `usize` |

#### 其他

##### 变量解构

`let` 表达式不仅能用于变量的绑定，还能用于复杂变量的结构，也就是从一个复杂的变量中匹配出该变量的一部分

```rust
fn main() {
	let (a, mut b) = (true, false);
	// a 为不可变，b 为可变，因为用了 mut 关键字
    println!("{} {}", a, b);

    b = true;

    println!("{} {}", a, b);
}
```

在 `Rust 1.59` 版本之后还有可以在赋值语句的左侧使用，元组、切片、结构体模式

```rust
// 这里声明了一个结构体可以先不管他
struct Struct {
    e: i32
}

fn main() {
	// 先声明了变量，但是并没有绑定值
	let (a, b, c, d, e);
	// 这里 a, b 解构了右侧的元组并绑定值
	(a, b) = (1, 2);
	// 这里 .. 表示忽略了中间值，而 _ 表示忽略一个元素
	[c, .., d, _] = [1, 2, 3, 4, 5];
	// 这里就只匹配了结构体中的 e 其他的则忽略
	Struct { e, .. } = Struct { e: 5 };

	println!("{} {} {} {} {}", a, b, c, d, e);
}
```

这里和之前的结构方式是一样的，不过之前时重新绑定，而这里是对之前声明的变量再绑定
### 数据类型

Rust 是一种静态类型语言，这意味着每个变量在声明时都必须指定数据类型，这使得编译器能够在编译时检查类型的正确性。
#### 常见数据类型

- **整型**: 用来表示整数的数据类型。
    - 有符号整型（`i<size>`）: 能存储正负整数。
    - 无符号整型（`u<size>`）: 仅存储正整数。
    - `<size>`: 指定位数，如 `i8`, `u32`。
    - `usize`/`isize`: 依据操作系统架构（32 位或 64 位）定义大小。
- **浮点型**: 存储小数点数值，分为单精度（`f32`）和双精度（`f64`）。
- **布尔型**: 表示逻辑真（`true`）和假（`false`）。
- **字符型**: 存储单个 Unicode 标量值，如 `'a'`、`'我'`、`'😊'`。
- **字符串型**:
    - `String`: 可变、可增长、拥有所有权的 UTF-8 文本字符串。
    - `&str`: 不可变的字符串切片，经常用于借用文本。
- **数组**: 固定大小的同类型数据集合，如 `[i32; 5]` 表示一个包含 5 个 `i32` 类型元素的数组。
- **元组**: 可存储多种类型的固定数量集合。
	- 可以包含不同数据类型的固定数量元素，例如 `(32, 'a')`


#### 其他

##### 变量解构

`let` 表达式不仅能用于变量的绑定，还能用于复杂变量的结构，也就是从一个复杂的变量中匹配出该变量的一部分

```rust
fn main() {
	let (a, mut b) = (true, false);
	// a 为不可变，b 为可变，因为用了 mut 关键字
    println!("{} {}", a, b);

    b = true;

    println!("{} {}", a, b);
}
```

在 `Rust 1.59` 版本之后还有可以在赋值语句的左侧使用，元组、切片、结构体模式

```rust
// 这里声明了一个结构体可以先不管他
struct Struct {
    e: i32
}

fn main() {
	// 先声明了变量，但是并没有绑定值
	let (a, b, c, d, e);
	// 这里 a, b 解构了右侧的元组并绑定值
	(a, b) = (1, 2);
	// 这里 .. 表示忽略了中间值，而 _ 表示忽略一个元素
	[c, .., d, _] = [1, 2, 3, 4, 5];
	// 这里就只匹配了结构体中的 e 其他的则忽略
	Struct { e, .. } = Struct { e: 5 };

	println!("{} {} {} {} {}", a, b, c, d, e);
}
```

这里和之前的结构方式是一样的，不过之前时重新绑定，而这里是对之前声明的变量再绑定
#### 特征对象

就是允许对具有相同特征的不同类型做出相同的操作，如，我们有一个动物的特征，可能是猫、狗、鱼，无论是什么只要是动物，那么我们就可以做一些相同的行为，例如让他们都动起来，具体是怎么动的无论是跑还是游都不关注，只要能动就行。这样的好处是可以将多种不同的类型放在一起，对外统称为动物就好，代码更加的灵活方便

在这之前要知道一个概念，**动态分发（DYnamic Dispatch）**，当代码在使用一种特定的类型的适合，不用具体知道是哪一个类型，而是在运行的时候决定具体调用哪个类型的实现，不过毕竟是在运行时，也会有一点性能损失，但是却更为灵活了，

而特征对象就是一个指针，指向实现特定特征的数据，还能得到一个指向虚拟方法表的指针，包含运行时需要用到的方法，编译器编译时生成

特征对象可以通过两种方式来创建

- 引用 `&dyn Trait`
- 通过盒子（box） `Box<dyn Trait>`

使用 `dyn` 关键字来动态分发，表示遵循这个特征类型就可以了，但是现在不确定是哪一个类型，等实际用到的时候再去找

> `Box<T>` ，现在把它当成一个引用即可，只不过它包裹的值会被强制分配在堆上。

这两种方式都运行在运行时多态的处理不同类型的数据，只要实现了相同特征

```rust
trait Talk {
	fn speak(&self);
}

struct Dog;
impl Talk for Dog {
	fn speak(&self) {
		println!("旺旺");
	}
}

struct Cat;
impl Talk for Cat {
	fn speak(&self) {
		println!("妙妙");
	}
}

fn speak1(animal: Box<dyn Talk>) {
	animal.speak();
}

fn speak2(animal: &dyn Talk) {
	animal.speak();
}

let dog1 = Dog;
let cat1 = Cat;

// 这里会转移所有权所以要么克隆一下，或者使用基本数据类型
speak1(Box::new(Dog);
// 这里相当于重新创建了一个新的实例
speak1(Box::new(Cat));

speak2(&dog1);
speak2(&cat1);

// 输出
// 旺旺
// 妙妙
// 旺旺
// 妙妙
```

> 在这里因为  `Dog` 等是一个单元结构体，所以只使用 `Dog` 就能创建一个实例

- 静态分发（static dispatch）
	- 编译期间完成，为每一个泛型参数对应的具体类型生成一份代码，不影响运行性能
- 动态分发（dynamic dispatch）
	- 运行时才能确定要调用的方法，`dyn` 关键字强调的就是动态这一特点，当使用特征对象时就必须要使用动态分发，因为编辑器无法知道所有可能用于特征对象代码的类型

![[动态分发与静态分发.png]]

> Rust 中的 Self  指代特征或者方法类型的别名， self  指代当前实例的对象


#### 特征对象的限制

并不是所有特征都能拥有特征对象，只有对象安全的特征才行。当一个特征的所有方法都有如下属性时，他的对象才是安全的

- 方法的返回类型不能是 `Self`
	- 静态分发的场景崽编译的时候就确定了返回类型，返回实现该特征的类型的实例，如果是动态分发，具体类型是在运行时决定的，如果返回一个 `Self` 类型，编译器无法具体知道应该返回那个类型实例。
- 方法没有任何泛型参数
	- 泛型参数在编译的时候被具体化，依赖于编译时已知的具体类型，如果一个特征方法有泛型参数，在它被用于特征对象时就不能明确参数类型了，因为特征类型时运行时才能确定具体实现的


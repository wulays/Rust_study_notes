#### 特征对象

就是允许对具有相同特征的不同类型做出相同的操作，如，我们有一个动物的特征，可能是猫、狗、鱼，无论是什么只要是动物，那么我们就可以做一些相同的行为，例如让他们都动起来，具体是怎么动的无论是跑还是游都不关注，只要能动就行。这样的好处是可以将多种不同的类型放在一起，对外统称为动物就好，代码更加的灵活方便

在这之前要知道一个盖帘，**动态分发（DYnamic Dispatch）**，当代码在使用一种特定的类型的适合，不用具体知道是哪一个类型，而是在运行的时候决定具体调用哪个类型的实现，不过毕竟是在运行时，也会有一点性能损失，但是却更为灵活了，

而特征对象就是一个指针，指向实现特定特征的数据，还能得到一个指向虚拟方法表的指针，包含运行时需要用到的方法，编译器编译时生成

特征对象可以通过两种方式来创建

- 引用 `&dyn Trait`
- 通过盒子（box） `Box<dyn Trait>`

使用 `dyn` 关键字来动态分发，表示遵循这个特征类型就可以了，但是现在不确定是哪一个类型，等实际用到的时候再去找

> `Box<T>` ，现在把它当成一个引用即可，只不过它包裹的值会被强制分配在堆上。

这两种方式都运行在运行时多态的处理不同类型的数据，只要实现了相同特征

```rust
trait Talk {
	fn speak(&self);
}

struct Dog;
impl Talk for Dog {
	fn speak(&self) {
		println!("旺旺");
	}
}

struct Cat;
impl Talk for Cat {
	fn speak(&self) {
		println!("妙妙");
	}
}

fn speak1(animal: Box<dyn Talk>) {
	animal.speak();
}

fn speak2(animal: &dyn Talk) {
	animal.speak();
}

let dog1 = Dog;
let cat1 = Cat;

// 这里会转移所有权所以要么克隆一下，或者使用基本数据类型
speak1(Box::new(Dog);
// 这里相当于重新创建了一个新的实例
speak1(Box::new(Cat));

speak2(&dog1);
speak2(&cat1);

// 输出
// 旺旺
// 妙妙
// 旺旺
// 妙妙
```

> 在这里因为  `Dog` 等是一个单元结构体，所以只使用 `Dog` 就能创建一个实例


#### 生命周期

什么是生命周期，就是引用的作用域。每个引用都有一个生命周期，用来表示指向的数据保持有效的时间段，大多数时候都无需手动声明生命周期，因为编译器会自动进行推导。

生命周期并不改变任何引用的寿命，用来告诉编译器如何关联推到，避免垂悬引用等问题。

```rust
{
	let a;

	{
		let b = 10;
		a = &b;
	} // b 销毁

	println!("{}", a);
}
```

`b` 在作用域结束之后就会被释放，然而 `a` 却引用了 `b` 在作用域结束之后 `a` 依然有效，然而引用的 `b` 被释放了，这个时候 `a` 就是一个悬垂指针，他引用了提前被释放的变量 `b`，这个时候代码就会报错

为了确保所有权和借用的准确性，Rust 是用来一个借用检查器来检查程序的借用正确性

```rust
{
	let a;               // -------+-- 'a
                         //           |
	{                    //           |
		let b = 10;      // -+-- 'b   |
		a = &b;          //  |        |
	}                    // -+        |
                         //           |
	println!("{}", a);   //           |
}                        // -------+
```

和之前的代码一样，不过对变量加了一些注释，用来表示生命周期的作用域，图中可以明显看出 `'b` 的生命周期比 `'a` 的小很多

在编译期间 Rust 就会比较两个生命周期，结果发现 `a` 密码拥有生命周期 `'a` ，但是却引用了一个小很多的生命周期 `'b` 这种情况下编译器就会认为我们的代码有风险，就会拒绝运行，如果要想通过编译，只需要 `'b` 的生命周期比 `'a` 的大就可以了

```rust
{
	let x = 10;            //  ---------+-- 'a
	                       //           |
	let y = &x;            // ---+--'b' |
                           //    |      |
	println!("{}", y)      //    |      |
}                          // ---+------+
```

这样就可以通过编译了因为 `'a` 的生命周期比 `'b` 的大

#### 函数中的生命周期

考虑一个问题，当一个函数接受两个字符串切片参数，然后返回其中长度最长的一个

```rust
fn longest(x: &str, y: &str) -> &str {
	if x.len() > y.len() {
		x
	} else {
		y
	}
}
```

这样看起来是很美好的，然后实际去执行的时候却报错了。因为编译器无法知道函数的返回值会是 `x` 还是 `y` ，推导不出来了。这就难受了，因为我们也不知道到时候会返回哪一个引用

这个时候就需要手动的去标注生命周期了，不过也要记住 **标记的生命周期只是为了帮助编译器推导，并不影响实际变量的生命周期** 使用 `'` 开头来标记一个生命周期，名称往往是一个单独的小写字母

```rust
&i32        // 一个引用
&'a i32     // 具有显式生命周期的引用
&'a mut i32 // 具有显式生命周期的可变引用
```

如何去做一个标注呢，如同之前所说，我们也是不知道应该返回哪个生命周期的。那应该如何标注。这个时候就不用去考虑哪个生命周期活的更久了，只需要表征他们在这个函数中至少活得一样久就好了

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
	if x.len() > y.len() { x } else { y }
}
```

- 和泛型一样，使用生命周期参数，需要先声明 `<'a>`
- `x`、`y` 和返回值至少活得和 `'a` 一样久(因为返回值要么是 `x`，要么是 `y`)

**在通过函数签名指定生命周期参数时，我们并没有改变传入引用或者返回引用的真实生命周期，而是告诉编译器当不满足此约束条件时，就拒绝编译通过**

因此 `longest` 函数并不知道 `x` 和 `y` 具体会活多久，只要知道它们的作用域至少能持续 `'a` 这么长就行。

函数返回值如果是一个引用类型，那么它的生命周期只会来源于

- 函数参数的生命周期
- 函数体中某个新建引用的生命周期

如果是第二种情况就是典型的垂悬引用了

```rust
fn test<'a>(x: &str, y: &str) -> &'a str {
	let result = String::from("test");
	&a
}
```

这种情况，主要问题就是 `result` 在函数结束之后就会释放，然而对 `result` 的引用仍然在继续，指定声明周期也是没有用的，这种情况最好的办法就是直接返回所有权了

```rust
fn test<'a>(x: &str, y: &str) -> String {
	String::from("test");
}
```

生命周期也是没有用到的，哈哈

#### 结构体中的生命周期

结构体中也是有生命周期的，作用就是确保结构体有效期间，结构体里面的引用类型的字段也是有效的，也就是字段的生命周期要大于等于这个结构体的生命周期

```rust
struct Test<'a> {
	name: &'a str
}

fn main() {
	let test;

	{
		let a = String::from("test");

		test = Test {
			name: &a;
		}
	}
}
```

这就会报错了，可以看出结构体比引用的字符串活的更久

实际上对于编译器来说，每一个类型都有一个生命周期，不过在使用的过程中，很多时候都无需去标注生命周期，因为编译器能够推断出来，特殊情况会有歧义的时候就需要手动的标注帮助编译器来进行推导了

> 在 Rust 1.0 之前，是要求必须显式标注所有引用的生命周期的，不过太麻烦了，然后哈哈

- 消除规则不是万能的，若编译器不能确定某件事是正确时，会直接判为不正确，那么你还是需要手动标注生命周期
- **函数或者方法中，参数的生命周期被称为 `输入生命周期`，返回值的生命周期被称为 `输出生命周期`**

三条消除规则，编译器使用三条消除规则来确定哪些场景不需要显式地去标注生命周期

其中第一条规则应用在输入生命周期上，第二、三条应用在输出生命周期上，若编译器发现三条规则都不适用时，就会报错，提示你需要手动标注生命周期。

1. **每一个引用参数都会获得独自的生命周期**
    
    例如一个引用参数的函数就有一个生命周期标注: `fn foo<'a>(x: &'a i32)`，两个引用参数的有两个生命周期标注:`fn foo<'a, 'b>(x: &'a i32, y: &'b i32)`, 依此类推。
    
2. **若只有一个输入生命周期(函数参数中只有一个引用类型)，那么该生命周期会被赋给所有的输出生命周期**，也就是所有返回值的生命周期都等于该输入生命周期
    
    例如函数 `fn foo(x: &i32) -> &i32`，`x` 参数的生命周期会被自动赋给返回值 `&i32`，因此该函数等同于 `fn foo<'a>(x: &'a i32) -> &'a i32`
    
3. **若存在多个输入生命周期，且其中一个是 `&self` 或 `&mut self`，则 `&self` 的生命周期被赋给所有的输出生命周期**
    
    拥有 `&self` 形式的参数，说明该函数是一个 `方法`，该规则让方法的使用便利度大幅提升。

#### 方法中的生命周期

```rust
struct Test<'a> {
	name: &'a str
}

impl<'a> Test<'a> {
	fn eat(&self) -> i32 {
		10
	}
}
```

`impl` 中必须使用结构体的完整名称，包括 `'a` 因为生命周期标注也是结构体类型的一部分，不过在方法签名中，往往是不用标注生命周期的，着得益于生命周期消除规则一和三

如果是方法有多个参数的话，看起来就像这样

```rust
impl<'a> Test<'a> {
	fn eat<'b>(&self, food: &'b str) -> &str {
		// ...
	}
}
```

因为编译器不知道 `food` 的生命周期有多长，也不知道和 `'a` 的关系，所以就会重新声明一个生命周期 `'b`，返回值的生命周期根据规则默认为 `'a` 也就是 `self` 的生命周期

如果这个时候手动去改了返回值的生命周期，给他改成 `'b`

```rust
impl<'a> Test<'a> {
	fn eat<'b>(&self, food: &'b str) -> &'b str {
		// ...
	}
}
```

这个时候就会报错了，因为 编译器不知道  `'a` 和 `'b` 的关系，也不知道在 `’a`  有效的期间 `'b` 是否有效，这一点也很容易知道就是 `'b` 要比 `'a` 活的长，不然就会出现垂悬引用

```rust
impl<'a: 'b, 'b> Test<'a> {
	fn eat(&self, food: &'b str) -> &'b str {
		// ...
	}
}
```

这个时候就不会报错了，因为约束了 `'a` 有效的期间 `'b` 必须有效，也可以使用 `where` 来分开声明

```rust
impl<'a> Test<'a> {
	fn eat<'b>(&self, food: &'b str) -> &'b str
	where
		'a: 'b
	{
		// ...
	}
}
```

也就是高数编译器，引用给的内容活的更久，这样无论如何都不会引用到无效内容

#### 静态生命周期

Rust 中有一个特殊的生命周期 `'static` 拥有这个生命周期的引用表示可以活的和程序一样久。在这之前学到的字符串字面量就是这种，因为他是被硬编码进文件中的

```rust
let s: &'static str = "test";
```

当很确定所引用的生命周期都是正确的时候就可以大胆的用 `'static`  了

- 生命周期 `'static` 意味着能和程序活得一样久，例如字符串字面量和特征对象
- 实在遇到解决不了的生命周期标注问题，可以尝试 `T: 'static`，有时候它会给你奇迹

`'static` 是生命周期的标注，而 `T: 'static` 则是对类型的约束

#### 泛型、特征约束示例

泛型是可以和生命周期一起使用的

```rust
fn foo<'a, T>(x: &'a str, y: &'a str, z: T) -> &'a str
where
	T: Display
{
	///...
}
```
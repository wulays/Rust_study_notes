#### 字符串

`str` 类型是硬编码进可执行文件，也无法被修改，但是 `String` 则是一个可增长、可改变且具有所有权的 UTF-8 编码字符串，使用 `String::from` 将一个字符串字面量类型转换为了`String`

```rust
let s = "test";
let s1 = String::from(s);

println!("{} {}", s, s1);
// 输出 test test
```

**Rust 中的字符是 Unicode 类型，因此每个字符占据 4 个字节内存空间，但是在字符串中不一样，字符串是 UTF-8 编码，也就是字符串中的字符所占的字节数是变化的(1 - 4)**
#### 字符串切片

有时候只需要一整个字符串类型中的一部分，Rust 提供了一种切片语法 `[开始索引..结束索引]` 的方式来进行切片

```rust
let s = "hello world";

let s1 = &s[6..11];

println!("{}", s1);
// 输出 world
```

语法和之前序列的使用方式一样，如果想要从零开始可以这样

```rust
let s = "hello world";

let s1 = &s[..5];
println!("{}", s1);
// 输出 hello
let s1 = &s[0..5];
println!("{}", s1);
// 输出 hello
```

如果想要截取到最后一个

```rust
let s = "hello world";

let s1 = &s[6..];
println!("{}", s1);
// 输出 world
let s1 = &s[6..s.len()];
println!("{}", s1);
// 输出 world
```

如果想完整截取

```rust
let s = "hello world";

let s1 = &s[..];
println!("{}", s1);
// 输出 hello world
let s1 = &s[0..s.len()];
println!("{}", s1);
// 输出 hello world
```

当然这种截取也需要格外小心，因为切片需要准确的分割字符，也就是 `UTF-8`的字符边界，如果是占用多个字节的字符，截取不完整的话就会出问题了

```rust
let s = "中文";
let s1 = &s[..2];

println!("{}", s1);
```

这里的字符串一个字占了三个字节，而这里只截取了两个，所以就报错了无法通过编译

切片的类型标识符为 `&str`， 像之前的切片，字符串字面量就是这一种不可变引用类型

```rust
fn main() {
	let s = String::from("hello world");	

	let s1 = console_log(&s);

	println!("{}", s1);
}

fn console_log(s: &str) -> &str {
	let s1 = &s[..5];

	println!("{}", s1);

	s1
}
```

除了 `String` 类型的字符串之外 Rust 还提供了其他类型的字符串

- OsString
- OsStr
- CsString
- CsStr
分别对应着所有权和被借用变量，不过一般说字符**指的就是 `String` 类型和 `&str` 字符串切片类型**

#### String 与 &str 转换

使用 `String::from` 或则 `.to_string` 方法

```rust
let s = String::from("test");
let s1 = "test".to_string();
```

如果要转为 `&str` 呢，就像之前一样取引用就可以了

```rust
let s = String::from("test");

let s1 = &s;
let s1 = &s[..];
let s1 = &s.as_str();
```

这种灵活用法是因为 `deref` 隐式强制转换

虽然可以进行切片，但是Rust中是不允许直接进行字符串索引的

```rust
let s = String::from("test");

let s1 = s[0];
```

这是因为字符串地产实际是使用的 `[u8]` 字节数组来进行存储的，而像之前一样的中文或者别的什么情况，取出来也没有意义

```rust
let s = String::from("中国");
// 这个字符串的长度是 6 ，而并不是2，因为一个中文占了3个字节
```

这就是为什么无法这样取的原因了，我们期望的是取一个字符，而Rust 无法保证这一点，包括字符切片都是需要格外小心的

#### 字符串操作

毕竟  `String` 是可以修改的，那么这里开始对他进行一些修改吧，搜先需要一个可修改的字符串变量

追加

```rust
let mut s = String::from("hell");

// 追加字符
s.push('o');

// 追加字符串
s.push_str(" world");
```

指定位置插入

```rust
let mut s = String::from("hlloorld");

// 插入字符
s.insert(1, 'e');

// 插入字符串
s.insert_str(5, " w");
```

替换，**该方法是返回一个新的字符串，而不是操作原来的字符串**。

```rust
let s = String::from("hello wrold");

// 第一个参数是要被替换的字符串，第二个参数是新的字符串
let s1 = s.replace("wrold", "world");

let s2 = s.replacen("o", "haha", 2); // 第三个参数则表示替换的个数
```
